#summary A quick guide to adding buildings to Stonesense

= Adding Buildings to Stonesense =

This is a brief summary of how to add new building sprites to Stonesense.

Some familiarity with the way [Sprites] work in general would be useful.

= Sprite graphics =

First new graphics will need to be developed for the buildings. Then they will need to be added to _objects.png_ as per the instructions on [Sprites]. You will need to know the indexes of the sprites. While you can figure these out by counting, there is a shortcut: within Stonesense, hit F10 and the objects.png will be displayed, with index numbers superimposed.

= _buildingname_.xml =

To tell Stonesense what to do with the graphics you have added, you need to define the building in an xml file. Create one with a sensible name in the _buildings_ folder, and add it to the list in _index.txt_

_hint:_ why not make a copy of the most similar building.xml instead of starting from scratch?

= XML format =

Here is an annotated sample of the XML format used in the building.xml

{{{
<?xml version="1.0" ?> <!-- this lets the xml parser know that your file is xml -->

<Building name="Cabinet" gameID="cabinet">
<!-- Building is the root node of the xml file. You can only have one per file -->
<!-- The name attribute doesnt do much yet, but may be used for UI stuff later -->
<!-- the gameID must match what the debug interface on stonesense returns -->

	<Tile>
	<!-- Each potential display element is a Tile node -->

		<Condition type="MaterialType" value="Wood" />
		<!-- A tile can have conditions that determine whether to use that tile -->
		<!-- The first tile with all matching conditions is the one displayed -->
		<!-- More on these below -->

		<Sprite sheetIndex = 88 />
		<!-- And here's what you were waiting for -->
		<!-- This Sprite node tells Stonesense to use graphic 88 for the cabinet -->
		<!-- More tricks to use on this below, too -->

	</Tile> <!-- The end of this tile node -->

	<Tile> <!-- Another tile element -->
		<Sprite sheetIndex = 87 />
	</Tile> <!-- Without a condition tag, this tile will make anything that isnt already drawn use graphic #87 -->
	
</Building> <!-- any xml tag needs a closing tag to match, or to have its own closing slash before the right angle bracket -->

}}}

= Tile Conditions =

A tile must match all the condition entries to be displayed (There's no OR style syntax. Yet). The first matching tile is displayed, so put more complex conditions above and more generic conditions below.

A side benefit of this is used in workshops: We wrote the 'border' tiles and put them unchanged a the bottom of each workshop. Then we put the actual workshop graphics above. Only the tiles that we dont otherwise specify get the generic border.

== List of Condition Options ==

  * *!PositionIndex*: Matches on the location of a tile within a building. Used in multitile buildings such as workshops. Less effective on anything with non-fixed dimensions. The index is from west to east then north to south, and is zero based, eg:
  || 0 || 1 || 2 ||
  || 3 || 4 || 5 ||
  || 6 || 7 || 8 ||

  * *!MaterialType*: Name of a type of material that the construction is made from. This is general material only, not specific subtype. Sometimes the material may be surprising, such as all forges are considered 'metal' because it takes the material type from the anvil.
  || Wood || Stone || Metal || Leather || Slik ^1^ || 
  || !PlantCloth || !GreenGlass || !ClearGlass || !CrystalGlass || 
  ^1^ until a bugfix release...

  * *!NeighbourWall*: Detects whether one of the cells neighbors is solid rock or constructed wall. Good for determining orientations of doors and similar. Remember that you can use multiple conditions to eg search for a wall the the north and one to the west.
  || None || North || South || West || East ||

  * *!NeighbourSameBuilding*: Detects whether one of the cells neighbors is of the same type of building. Note that it does *not* pay any attention to whether is is actually part of the same building, or just another built alongside. Useful for edges of buildings that should merge with their neighbors, or where !PositionIndex wont work due to changing shape. Use multiple entries for more complex neighbor arrangements
  || None || North || South || West || East ||

= Advanced Sprites =

Firstly, a tile can contain multiple sprites. This is useful where parts of a tile can be used repeatedly. The bench in a workshop, for example, is separate from the tools and objects. By drawing a bench, then drawing eg a tool, the same bench can be used repeatedly, and can be swapped out for benches of other materials.

A tile can also contain no sprites, which is how you get an undrawn tile instead of a default box.

To assist in combining sprites, it is possible to offset the sprites before they are drawn. Adding an offsetx and offsety attribute with appropriate integer values to the Sprite tag will achieve this.

_hacky trick:_ Sprites with offsets are clipped *before* the offset is applied, of course. This means that they can be drawn outside the boundaries of the original sprite. So if you *really* needed a tile to be drawn taller than 32 pixels, you could draw the lower part with one sprite, and the upper part with another, offset, sprite. Of course, it wouldn't *really* be taller, and thus might interact with the rest of the terrain in strange ways.