#include "common.h"
#include "GUI.h"
#include "MapLoading.h"
#include "WorldSegment.h"
#include "Constructions.h"
#include "GameBuildings.h"
#include "ContentLoader.h"

static DFHack::Context* pDFApiHandle = 0;
static DFHack::ContextManager* DFMgr = 0;
const VersionInfo *dfMemoryInfo;
bool memInfoHasBeenRead;
bool connected = 0;

inline bool IDisWall(int in){
	//if not a custom type, do a lookup in dfHack's interface
	return isWallTerrain( in );
}

inline bool IDisFloor(int in){
	//if not a custom type, do a lookup in dfHack's interface
	return isFloorTerrain( in );;
}

//big look up table
char rampblut[] =
// generated by blutmaker.py
{
	1 ,  2 ,  8 ,  2 ,  4 , 12 ,  4 , 12 ,  9 ,  2 , 21 ,  2 ,  4 , 12 ,  4 , 12 ,
	5 , 16 ,  5 , 16 , 13 , 13 , 13 , 12 ,  5 , 16 ,  5 , 16 , 13 , 13 , 13 , 16 ,
	7 ,  2 , 14 ,  2 ,  4 , 12 ,  4 , 12 , 20 , 26 , 25 , 26 ,  4 , 12 ,  4 , 12 ,
	5 , 16 ,  5 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 ,  5 , 16 , 13 , 16 , 13 , 16 ,
	3 , 10 ,  3 , 10 , 17 , 12 , 17 , 12 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
	11 , 10 , 11 , 16 , 11 , 26 , 17 , 12 , 11 , 16 , 11 , 16 , 13 , 13 , 17 , 16 ,
	3 , 10 ,  3 , 10 , 17 , 17 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
	11 , 11 , 11 , 16 , 11 , 11 , 17 , 14 , 11 , 16 , 11 , 16 , 17 , 17 , 17 , 13 ,
	6 ,  2 , 19 ,  2 ,  4 , 12 ,  4 , 12 , 15 ,  2 , 24 ,  2 ,  4 , 12 ,  4 , 12 ,
	5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,
	18 ,  2 , 22 ,  2 , 26 , 12 , 26 , 12 , 23 , 26 , 26 , 26 , 26 , 12 , 26 , 12 ,
	5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,  5 , 16 , 26 , 16 , 13 , 16 , 13 , 16 ,
	3 , 10 ,  3 , 10 , 17 , 10 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
	11 , 10 , 11 , 16 , 17 , 10 , 17 , 17 , 11 , 16 , 11 , 16 , 17 , 15 , 17 , 12 ,
	3 , 10 ,  3 , 10 , 17 , 17 , 17 , 17 ,  3 , 10 , 26 , 10 , 17 , 17 , 17 , 17 ,
	11 , 16 , 11 , 16 , 17 , 16 , 17 , 10 , 11 , 16 , 11 , 16 , 17 , 11 , 17 , 26
};

bool isBlockOnVisibleEdgeOfSegment(WorldSegment* segment, Block* b)
{
	if(b->z == segment->z + segment->sizez - 2) 
		return true;

	if (DisplayedRotation == 0 && 
		(
		b->x == segment->x + segment->sizex - 2
		|| b->y == segment->y + segment->sizey - 2
		|| b->x == segment->regionSize.x - 1
		|| b->y == segment->regionSize.y - 1
		))
	{
		return true;
	}
	else if (DisplayedRotation == 1 &&
		(
		b->x == segment->x + segment->sizex - 2
		|| b->y == segment->y + 1
		|| b->x == segment->regionSize.x - 1
		|| b->y == 0
		))
	{
		return true;
	}
	else if (DisplayedRotation == 2 &&
		(
		b->x == segment->x + 1
		|| b->y == segment->y + 1
		|| b->x == 0
		|| b->y == 0
		))
	{
		return true;
	}
	else if (DisplayedRotation == 3 && 
		(
		b->x == segment->x + 1
		|| b->y == segment->y + segment->sizey - 2
		|| b->x == 0
		|| b->y == segment->regionSize.y - 1
		))
	{
		return true;
	}

	return false;
}

bool areNeighborsVisible(t_designation designations[16][16],int  x,int y)
{
	if(designations[x-1][y-1].bits.hidden == false)
		return true;
	if(designations[x-1][y].bits.hidden == false)
		return true;
	if(designations[x-1][y+1].bits.hidden == false)
		return true;
	if(designations[x][y-1].bits.hidden == false)
		return true;
	if(designations[x][y+1].bits.hidden == false)
		return true;
	if(designations[x+1][y-1].bits.hidden == false)
		return true;
	if(designations[x+1][y].bits.hidden == false)
		return true;
	if(designations[x+1][y+1].bits.hidden == false)
		return true;
	return false;
}

void ReadCellToSegment(DFHack::Context& DF, WorldSegment& segment, int CellX, int CellY, int CellZ,
					   uint32_t BoundrySX, uint32_t BoundrySY,
					   uint32_t BoundryEX, uint32_t BoundryEY, 
					   uint16_t Flags/*not in use*/, 
					   vector<t_building>* allBuildings, 
					   vector<t_construction>* allConstructions,
					   vector< vector <uint16_t> >* allLayers,
					   vector<DFHack::t_feature> * global_features,
					   std::map <DFHack::planecoord, std::vector<DFHack::t_feature *> > *local_features,
					   DFHack::Maps *Maps)
{
	if(config.skipMaps)
		return;

	//boundry check
	int celldimX, celldimY, celldimZ;
	Maps->getSize((unsigned int &)celldimX, (unsigned int &)celldimY, (unsigned int &)celldimZ);
	if( CellX < 0 || CellX >= celldimX ||
		CellY < 0 || CellY >= celldimY ||
		CellZ < 0 || CellZ >= celldimZ ) 
		return;
	if(!(DF.isSuspended()))
		DisplayErr("DF isn't suspended! something is very very wrong!");
	if(!Maps->isValidBlock(CellX, CellY, CellZ))
		return;


	//make boundries local
	BoundrySX -= CellX * CELLEDGESIZE;
	BoundryEX -= CellX * CELLEDGESIZE;
	BoundrySY -= CellY * CELLEDGESIZE;
	BoundryEY -= CellY * CELLEDGESIZE;


	//read cell data
	uint16_t tiletypes[16][16];
	t_designation designations[16][16];
	t_occupancy occupancies[16][16];
	uint8_t regionoffsets[16];
	t_temperatures temp1, temp2;
	DFHack::mapblock40d mapBlock;
	std::vector<t_tree> plants;
	Maps->ReadTileTypes(CellX, CellY, CellZ, (tiletypes40d *) tiletypes);
	Maps->ReadDesignations(CellX, CellY, CellZ, (designations40d *) designations);
	Maps->ReadOccupancy(CellX, CellY, CellZ, (occupancies40d *) occupancies);
	Maps->ReadRegionOffsets(CellX,CellY,CellZ, (biome_indices40d *)regionoffsets);
	Maps->ReadTemperatures(CellX, CellY, CellZ, &temp1, &temp2);
	Maps->ReadBlock40d(CellX, CellY, CellZ, &mapBlock);
	Maps->ReadVegetation(CellX, CellY, CellZ, &plants);

	//read local vein data
	vector <t_vein> veins;
	vector <t_frozenliquidvein> ices;
	vector <t_spattervein> splatter;

	try
	{
		Maps->ReadVeins(CellX,CellY,CellZ,&veins,&ices,&splatter);
	}
	catch (exception &e)
	{
		WriteErr("%DFhack exeption: s\n", e.what());
	}

	uint32_t numVeins = (uint32_t)veins.size();

	//parse cell
	for(uint32_t ly = BoundrySY; ly <= BoundryEY; ly++){
		for(uint32_t lx = BoundrySX; lx <= BoundryEX; lx++){
			uint32_t gx = lx + (CellX * CELLEDGESIZE);
			uint32_t gy = ly + (CellY * CELLEDGESIZE);
			if( !segment.CoordinateInsideSegment( gx, gy, CellZ) )
			{ 
				continue;
			}
			bool createdBlock = false;
			Block* b = segment.getBlock( gx, gy, CellZ);

			if (!b)
			{
				createdBlock = true;
				b = new Block ( &segment );
				b->x = gx;
				b->y = gy;
				b->z = CellZ;
			}

			b->occ = occupancies[lx][ly];
			b->designation = designations[lx][ly];
			b->mudlevel = 0;
			b->snowlevel = 0;
			b->bloodlevel = 0;
			//liquids
			if(designations[lx][ly].bits.flow_size > 0){
				b->water.type  = designations[lx][ly].bits.liquid_type;
				b->water.index = designations[lx][ly].bits.flow_size;
			}

			//read tiletype
			int t = tiletypes[lx][ly];
			b->tileType = t;

			//this only needs to be done for included blocks

			//determine rock/soil type
			int rockIndex = -1;
			if(regionoffsets[designations[lx][ly].bits.biome] < (*allLayers).size())
				if(designations[lx][ly].bits.geolayer_index < (*allLayers).at(regionoffsets[designations[lx][ly].bits.biome]).size())
					rockIndex = (*allLayers).at(regionoffsets[designations[lx][ly].bits.biome]).at(designations[lx][ly].bits.geolayer_index);
			for(uint32_t i=0; i<numVeins; i++)
			{
				//TODO: This will be fixed in dfHack at some point, but right now objects that arnt veins pass through as. So we filter on vtable

				//if((uint32_t)veins[i].type >= groundTypes.size())
				//continue;

				// DANGER: THIS CODE MAY BE BUGGY
				// This was apparently causing a crash in previous version
				// But works fine for me
				uint16_t row = veins[i].assignment[ly];
				bool set = (row & (1 << lx)) != 0;
				if(set){
					rockIndex = veins[i].type;
					b->material.type = INORGANIC;
					b->material.index = veins[i].type;
				}
				else
				{
					b->material.type = INORGANIC;
					b->material.index = rockIndex;
				}
			}

			//read global features
			int16_t idx = mapBlock.global_feature;
			if( idx != -1 && (uint16_t)idx < global_features->size() && global_features->at(idx).main_material != -1)
			{
				if(designations[lx][ly].bits.feature_global)
				{
					//if(global_features->at(idx).main_material == INORGANIC) // stone
					//{
					//there may be other features.
					b->material.type = global_features->at(idx).main_material;
					b->material.index = global_features->at(idx).sub_material;
					//}
				}
			}

			//read local features
			idx = mapBlock.local_feature;
			if( idx != -1 )
			{
				DFHack::planecoord pc;
				pc.dim.x = CellX;
				pc.dim.y = CellY;
				std::map <DFHack::planecoord, std::vector<DFHack::t_feature *> >::iterator it;
				it = local_features->find(pc);
				if(it != local_features->end())
				{
					std::vector<DFHack::t_feature *>& vectr = (*it).second;
					if((uint16_t)idx < vectr.size() && vectr[idx]->main_material != -1)
					{
						if(mapBlock.designation[lx][ly].bits.feature_local)
						{
							//if(vectr[idx]->main_material == INORGANIC) // stone
							//{
							//We can probably get away with this.
							b->material.type = vectr[idx]->main_material;
							b->material.index = vectr[idx]->sub_material;
							//}
						}
					}
				}
			}

			if(tileTypeTable[b->tileType].material == OBSIDIAN)
			{
				b->material.type = INORGANIC;
				b->material.index = contentLoader.obsidian;
			}


			//string name = v_stonetypes[j].id;
			if (createdBlock)
			{
				segment.addBlock(b);
			}

		}
	}

	//add trees and other vegetation
	for(int i = 0; i < plants.size(); i++)
	{
		Block* b = segment.getBlock( plants[i].x, plants[i].y, CellZ);
		if(b && (
			(tileTypeTable[b->tileType].shape == TREE_DEAD) || 
			(tileTypeTable[b->tileType].shape == TREE_OK) ||
			(tileTypeTable[b->tileType].shape == SAPLING_DEAD) ||
			(tileTypeTable[b->tileType].shape == SAPLING_OK) ||
			(tileTypeTable[b->tileType].shape == SHRUB_DEAD) ||
			(tileTypeTable[b->tileType].shape == SHRUB_OK)
			))
		{
			b->material.type = plants[i].type;
			b->material.index = plants[i].material;
		}
	}
}

WorldSegment* ReadMapSegment(DFHack::Context &DF, int x, int y, int z, int sizex, int sizey, int sizez){
	uint32_t index;
	TMR2_START;
	DFHack::Maps *Maps;
	if(!config.skipMaps)
	{
		try
		{
			Maps = DF.getMaps();
		}
		catch (exception &e)
		{
			WriteErr("%DFhack exeption: s\n", e.what());
		}
	}
	DFHack::Materials *Mats;
	try
	{
		Mats = DF.getMaterials();
	}
	catch (exception &e)
	{
		WriteErr("DFhack exeption: %s\n", e.what());
	}
	DFHack::Constructions *Cons;
	if(!config.skipConstructions)
	{
		try
		{
			Cons = DF.getConstructions();
		}
		catch (exception &e)
		{
			WriteErr("DFhack exeption: %s\n", e.what());
			config.skipConstructions = true;
		}
	}
	DFHack::World *Wold;
	if(!config.skipWorld)
	{
		try
		{
			Wold = DF.getWorld();
		}
		catch (exception &e)
		{
			WriteErr("DFhack exeption: %s\n", e.what());
			config.skipWorld = true;
		}
	}

	if(!config.skipMaps)
	{
		if(!Maps->Start())
		{
			WriteErr("Can't init map.\n");
			DisconnectFromDF();
			//return new blank segment
			return new WorldSegment(x,y,z + 1,sizex,sizey,sizez + 1);
		}
	}
	else
	{
		//return new blank segment
		return new WorldSegment(x,y,z + 1,sizex,sizey,sizez + 1);
	}
	if( IsConnectedToDF() == false){
		DisconnectFromDF();
		//return new blank segment
		return new WorldSegment(x,y,z + 1,sizex,sizey,sizez + 1);
	}

	//read memory info
	if( memInfoHasBeenRead == false){
		dfMemoryInfo = DF.getMemoryInfo();
		memInfoHasBeenRead = true;
	}

	if (timeToReloadConfig)
	{
		contentLoader.Load(DF);
		timeToReloadConfig = false;
	}

	//read date
	if(!config.skipWorld)
	{
		contentLoader.currentYear = Wold->ReadCurrentYear();
		contentLoader.currentTick = Wold->ReadCurrentTick();
		contentLoader.currentMonth = (contentLoader.currentTick+9)/33600;
		contentLoader.currentDay = ((contentLoader.currentTick+9)%33600)/1200;
		contentLoader.currentHour = ((contentLoader.currentTick+9)-(((contentLoader.currentMonth*28)+contentLoader.currentDay)*1200))/50;
		contentLoader.currentTickRel = (contentLoader.currentTick+9)-(((((contentLoader.currentMonth*28)+contentLoader.currentDay)*24)+contentLoader.currentHour)*50);
	}

	//Read Number of cells
	int celldimX, celldimY, celldimZ;
	Maps->getSize((unsigned int &)celldimX, (unsigned int &)celldimY, (unsigned int &)celldimZ);
	//bound view to world
	if(x > celldimX * CELLEDGESIZE -sizex/2) DisplayedSegmentX = x = celldimX * CELLEDGESIZE -sizex/2;
	if(y > celldimY * CELLEDGESIZE -sizey/2) DisplayedSegmentY = y = celldimY * CELLEDGESIZE -sizey/2;
	if(x < -sizex/2) DisplayedSegmentX = x = -sizex/2;
	if(y < -sizey/2) DisplayedSegmentY = y = -sizey/2;

	//setup new world segment
	WorldSegment* segment = new WorldSegment(x,y,z,sizex,sizey,sizez);
	segment->regionSize.x = celldimX * CELLEDGESIZE;
	segment->regionSize.y = celldimY * CELLEDGESIZE;
	segment->regionSize.z = celldimZ;

	//read world wide buildings
	vector<t_building> allBuildings;
	if(!config.skipBuildings)
		ReadBuildings(DF, &allBuildings);

	/*if(GroundMaterialNamesTranslatedFromGame == false)
	TranslateGroundMaterialNames();*/

	// get region geology
	vector< vector <uint16_t> > layers;
	if(!Maps->ReadGeology( layers ))
	{
		WriteErr("Can't get region geology.\n");
	}
	// read constructions
	vector<t_construction> allConstructions;
	uint32_t numconstructions = 0;

	if(!config.skipConstructions)
	{
		try
		{
			if (Cons->Start(numconstructions))
			{
				t_construction tempcon;
				index = 0;
				while(index < numconstructions)
				{
					Cons->Read(index, tempcon);
					if(segment->CoordinateInsideSegment(tempcon.x, tempcon.y, tempcon.z))
						allConstructions.push_back(tempcon);
					index++;
				}
				Cons->Finish();
			}
		}
		catch(exception &e)
		{
			WriteErr("DFhack exception: %s\n", e.what());
			config.skipConstructions = true;
		}
	}

	//merge buildings with segment
	if(!config.skipBuildings)
		MergeBuildingsToSegment(&allBuildings, segment);

	//figure out what cells to read
	int32_t firstTileToReadX = x;
	if( firstTileToReadX < 0 ) firstTileToReadX = 0;

	//read global features
	vector<DFHack::t_feature> global_features;
	Maps->ReadGlobalFeatures(global_features);

	//read local features
	std::map <DFHack::planecoord, std::vector<DFHack::t_feature *> > local_features;
	Maps->ReadLocalFeatures(local_features);
	while(firstTileToReadX < x + sizex){
		int cellx = firstTileToReadX / CELLEDGESIZE;
		int32_t lastTileInCellX = (cellx+1) * CELLEDGESIZE - 1;
		int32_t lastTileToReadX = min<int32_t>(lastTileInCellX, x+sizex-1);

		int32_t firstTileToReadY = y;
		if( firstTileToReadY < 0 ) firstTileToReadY = 0;

		while(firstTileToReadY < y + sizey){
			int celly = firstTileToReadY / CELLEDGESIZE;
			int32_t lastTileInCellY = (celly+1) * CELLEDGESIZE - 1;
			int32_t lastTileToReadY = min<uint32_t>(lastTileInCellY, y+sizey-1);

			for(int lz=z-sizez; lz <= z; lz++){
				//load the blcoks from this cell to the map segment
				ReadCellToSegment(DF, *segment, cellx, celly, lz, 
					firstTileToReadX, firstTileToReadY, lastTileToReadX, lastTileToReadY,
					0, &allBuildings, &allConstructions, &layers, &global_features, &local_features, Maps);

			}
			firstTileToReadY = lastTileToReadY + 1;
		}
		firstTileToReadX = lastTileToReadX + 1;
	}

	//translate constructions
	changeConstructionMaterials(segment, &allConstructions);


	//uint32_t numtrees;
	//if(!config.skipVegetation)
	//{
	//	try
	//	{
	//		if (Veg->Start(numtrees))
	//		{
	//			t_tree temptree;
	//			index = 0;
	//			while(index < numtrees )
	//			{
	//				Veg->Read(index, temptree);
	//				//want hashtable :(
	//				Block* b;
	//				if( b = segment->getBlock( temptree.x, temptree.y, temptree.z) )
	//				{
	//					b->tree.type = temptree.type;
	//					b->tree.index = temptree.material;
	//				}
	//				index ++;
	//			}
	//			Veg->Finish();
	//		}
	//	}
	//	catch(exception &err)
	//	{
	//		WriteErr("DFhack exeption: %s\n", err.what());
	//		config.skipVegetation = true;
	//	}
	//}

	//do misc beautification
	uint32_t numblocks = segment->getNumBlocks();
	for(uint32_t i=0; i < numblocks; i++){
		Block* b = segment->getBlock(i);
		//setup building sprites

		//add edges to blocks and floors  

		Block * dir1 = segment->getBlockRelativeTo(b->x, b->y, b->z, eUpLeft);
		Block * dir2 = segment->getBlockRelativeTo(b->x, b->y, b->z, eUp);
		Block * dir3 = segment->getBlockRelativeTo(b->x, b->y, b->z, eUpRight);
		Block * dir4 = segment->getBlockRelativeTo(b->x, b->y, b->z, eRight);
		Block * dir5 = segment->getBlockRelativeTo(b->x, b->y, b->z, eDownRight);
		Block * dir6 = segment->getBlockRelativeTo(b->x, b->y, b->z, eDown);
		Block * dir7 = segment->getBlockRelativeTo(b->x, b->y, b->z, eDownLeft);
		Block * dir8 = segment->getBlockRelativeTo(b->x, b->y, b->z, eLeft);

		if(dir1) if((tileTypeTable[dir1->tileType].shape != EMPTY)) b->openborders |= 1;
		if(dir2) if((tileTypeTable[dir2->tileType].shape != EMPTY)) b->openborders |= 2;
		if(dir3) if((tileTypeTable[dir3->tileType].shape != EMPTY)) b->openborders |= 4;
		if(dir4) if((tileTypeTable[dir4->tileType].shape != EMPTY)) b->openborders |= 8;
		if(dir5) if((tileTypeTable[dir5->tileType].shape != EMPTY)) b->openborders |= 16;
		if(dir6) if((tileTypeTable[dir6->tileType].shape != EMPTY)) b->openborders |= 32;
		if(dir7) if((tileTypeTable[dir7->tileType].shape != EMPTY)) b->openborders |= 64;
		if(dir8) if((tileTypeTable[dir8->tileType].shape != EMPTY)) b->openborders |= 128;

		b->openborders = ~(b->openborders);
	}

	Maps->Finish();
	TMR2_STOP;

	return segment;
}


bool ConnectDFAPI(DFHack::Context* pDF){
	try
	{
		pDF->Attach();
	}
	catch(exception & err)
	{
		WriteErr("DFhack exeption: %s \n", err.what());
		return false;
	}
	catch(...)
	{
		return false;
	}
	//in case DF has locked up, force it's thread to resume
	pDF->ForceResume();
	return pDF->isAttached();
}

void DisconnectFromDF(){
	if(pDFApiHandle){
		//pDFApiHandle->getMaps()->DestroyMap();
		//in case DF has locked up, force it's thread to resume
		pDFApiHandle->ForceResume();
		pDFApiHandle->Detach();
		delete pDFApiHandle;
		pDFApiHandle = 0;
	}
}

bool IsConnectedToDF(){
	if(!pDFApiHandle) return false;
	return pDFApiHandle->isAttached();
}



void reloadDisplayedSegment(){
	//create handle to dfHack API
	
	bool firstLoad = (pDFApiHandle == 0);
	if(pDFApiHandle == 0){
		al_clear_to_color(al_map_rgb(0,0,0));
		draw_textf_border(font, al_map_rgb(255,255,255),
			al_get_bitmap_width(al_get_target_bitmap())/2,
			al_get_bitmap_height(al_get_target_bitmap())/2,
			ALLEGRO_ALIGN_CENTRE, "Connecting to DF...");
		al_flip_display();
		memInfoHasBeenRead = false;
		DFMgr = new ContextManager("Memory.xml");
		try
		{
			pDFApiHandle = DFMgr->getSingleContext();
			pDFApiHandle->Attach();
			pDFApiHandle->Detach();
		}
		catch (exception& e)
		{
			WriteErr("No Dwarf Fortress executable found\n");
			WriteErr("DFhack exeption: %s\n", e.what());
			delete( pDFApiHandle );
			pDFApiHandle = 0;
			return ;
		}
	}
	DFHack::Context& DF = *pDFApiHandle;
	if( !connected)
	{
		DF.Attach();
		connected = 1;
	}
	TMR1_START;

	//dispose old segment
	if(viewedSegment)
	{
		viewedSegment->Dispose();
		delete(viewedSegment);
	}

#ifndef RELEASE
	firstLoad=false;
#endif

	try
	{
		DF.Suspend();
	}
	catch (exception& e)
	{
		WriteErr("DFhack exeption: %s\n", e.what());
		return ;
	}

	DFHack::Gui * G = DF.getGui();

	//G->Start();
	//G->ReadViewScreen(config.viewscreen);
	//config.menustate = G->ReadMenuState();
	//G->Finish();
	DFHack::Maps *Maps;
	if(!config.skipMaps)
	{
		try
		{
			Maps = DF.getMaps();
		}
		catch (exception &e)
		{
			WriteErr("%DFhack exeption: s\n", e.what());
		}
		if(!Maps->Start())
		{
			WriteErr("Can't init map.\n");
		}
		else
		{
			//Read Number of cells
			int celldimX, celldimY, celldimZ;
			Maps->getSize((unsigned int &)celldimX, (unsigned int &)celldimY, (unsigned int &)celldimZ);
			//Store these
			config.cellDimX = celldimX * 16;
			config.cellDimY = celldimY * 16;
			config.cellDimZ = celldimZ;

			config.segmentSize.x = config.cellDimX + 2;
			config.segmentSize.y = config.cellDimY + 2;
			config.segmentSize.z = config.cellDimZ + 1;

			DisplayedSegmentX = 0;
			DisplayedSegmentY = 0;
			DisplayedSegmentZ = config.cellDimZ;

			Maps->getPosition(config.world_offsetX, config.world_offsetY, config.world_offsetZ);
		}
	}

	int segmentHeight = config.single_layer_view ? 2 : config.segmentSize.z;
	//load segment
	viewedSegment = ReadMapSegment(DF, DisplayedSegmentX, DisplayedSegmentY, DisplayedSegmentZ,
		config.segmentSize.x, config.segmentSize.y, segmentHeight);

	//if(!viewedSegment || viewedSegment->regionSize.x == 0 || viewedSegment->regionSize.y == 0)
	//{
	//	abortAutoReload();
	//	timeToReloadConfig = true;
	//}
	if( pDFApiHandle )
	{
		try
		{
			DF.Resume();
		}
		catch (exception& e)
		{
			WriteErr("DFhack exeption: %s\n", e.what());
			return ;
		}
	}
	TMR1_STOP;
}
